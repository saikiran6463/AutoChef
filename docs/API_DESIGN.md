üìÑ AutoChef API Design Document
1. Overview

AutoChef is a GenAI-powered Recipe Generator.
This API is the Java Spring Boot service that acts as a gateway between clients (frontend, Postman, API Gateway) and the Python LLM service.

MVP Objective: Accept a prompt (e.g., "I have chicken and garlic") and return structured recipe suggestions.

Future Objective: Support recipe retrieval, user preferences, analytics, and caching via DynamoDB.

2. Principles

MVP-first: Start small with one endpoint (POST /api/v1/generate-recipe).

Extensible: Design models and contracts with room to evolve (user preferences, cuisine(changed from local to cuisine), recipe IDs).

Production-minded: Separate concerns (Java gateway, Python LLM, DB layer).

Observability: Standard logging, error codes, CloudWatch integration later.

3. API Endpoints (The What)
   MVP

POST /api/v1/generate-recipe
Accepts a free-text prompt and returns recipe suggestions.

Future Extensions

GET /api/v1/recipes/{id} ‚Üí retrieve a specific recipe from DB.

GET /api/v1/recipes/history ‚Üí list recipes generated by a user.

POST /api/v1/recipes/feedback ‚Üí allow users to rate or refine recipes.

GET /health ‚Üí already available via Spring Actuator.

4. Data Models (The Nouns)
   RecipeRequest

Represents input from the user.

{
"prompt": "I have chicken and garlic",
"dietaryPreferences": ["low-carb"],
"cuisine": "italian",
}


Fields:

prompt (string, required) ‚Üí User‚Äôs text describing ingredients or constraints.

dietaryPreferences (array[string], optional) ‚Üí Filters like "vegetarian", "gluten-free".

cuisine (enum, required) -> For Cuisine Style

Recipe

Represents a recipe suggestion. Note the high-granularity fields for ingredients and cook time.

{
"title": "Garlic Chicken Stir Fry",
"ingredients": [
    { "name": "Chicken Breast", "quantity": 2, "unit": "pieces" },
    { "name": "Garlic", "quantity": 3, "unit": "cloves" },
    { "name": "Soy Sauce", "quantity": 2, "unit": "tablespoons" }
],
"instructions": "Heat oil, saut√© garlic, add chicken, stir-fry with vegetables and sauce.",
"cookTimeMinutes": 20
}


Fields:

title (string, required)

ingredients (array[object], required) ‚Üí Structured ingredient list. Each object contains `name` (string), `quantity` (number), and `unit` (string).

instructions (string, required)

cookTimeMinutes (integer, optional) ‚Üí Total cooking time in minutes for easy sorting/filtering.

RecipeResponse

Wrapper for a list of recipes.

{
"recipes": [ { ...Recipe... } ]
}

ErrorResponse

Standard error object with HTTP status code for enhanced debugging.

{
"status": 502,
"code": "LLM_DOWN",
"message": "Failed to reach recipe generation service."
}


Fields:

status (integer) ‚Üí HTTP status code for easier debugging and client handling.

code (string) ‚Üí machine-readable error code from centralized ErrorCode enum.

message (string) ‚Üí human-readable explanation.

5. Request/Response Payloads (The Conversation)
   Example Request
   POST /api/v1/generate-recipe
   Content-Type: application/json

{
"prompt": "I have chicken and garlic",
"dietaryPreferences": ["low-carb"]
}

Example Success Response (200)
{
"recipes": [
{
"title": "Garlic Chicken Stir Fry",
"ingredients": [
    { "name": "Chicken Breast", "quantity": 2, "unit": "pieces" },
    { "name": "Garlic", "quantity": 3, "unit": "cloves" },
    { "name": "Soy Sauce", "quantity": 2, "unit": "tablespoons" }
],
"instructions": "Heat oil, saut√© garlic, add chicken, stir-fry with vegetables and sauce.",
"cookTimeMinutes": 20
}
]
}

Example Error Response (502)
{
"code": "LLM_DOWN",
"message": "Failed to reach recipe generation service."
}

6. Business Logic (The How)
   Flow for POST /api/v1/generate-recipe

Input validation ‚Üí ensure prompt is present & non-empty.

Logging ‚Üí log request metadata (timestamp, request ID, prompt hash).

Forward to Python LLM Service ‚Üí call REST endpoint. The URL for this service will be externalized in `application.properties`.
    - **Implementation Strategy:**
        - The downstream call will be made using Spring's non-blocking `WebClient` (from the `spring-boot-starter-webflux` dependency).
        - A `WebClient` bean will be configured at startup with the base URL of the Python service.
        - The `RecipeServiceImpl` will use this `WebClient` bean to send the `RecipeRequest` and receive the `RecipeResponse`.

Response handling:

If success ‚Üí map response into RecipeResponse.

If failure ‚Üí return ErrorResponse with appropriate HTTP status.

Return to client ‚Üí JSON payload.

Error Handling Rules

400 Bad Request ‚Üí validation failed (e.g., empty prompt).

502 Bad Gateway ‚Üí Python LLM service unavailable.

504 Gateway Timeout ‚Üí Python LLM service is available but took too long to respond.

500 Internal Server Error ‚Üí unexpected exceptions.

## Comprehensive Error Handling Implementation

The Java gateway implements robust error handling with centralized error codes, custom exceptions, and comprehensive WebClient error wrapping.

### Architecture Components

**ErrorCode Enum** ‚Üí Centralized error codes and messages in `constants/ErrorCode.java`. Eliminates hardcoded strings and ensures consistency across the application.

**Custom Exceptions** ‚Üí Domain-specific exceptions that carry ErrorCode context:
- `ValidationException` ‚Üí Request validation failures (400 errors)
- `DownstreamServiceException` ‚Üí Python service issues (502/504 errors)

**ValidationService** ‚Üí Centralized request validation logic. Currently validates prompt requirements, easily extensible for future validation rules.

**GlobalExceptionHandler** ‚Üí Comprehensive exception handling using `@RestControllerAdvice`:
- Maps ValidationException ‚Üí 400 Bad Request
- Maps HttpMessageNotReadableException ‚Üí 400 Bad Request (malformed JSON)
- Maps DownstreamServiceException ‚Üí 502/504 based on error type
- Maps unexpected Exception ‚Üí 500 Internal Server Error

**Enhanced WebClient Integration** ‚Üí 30-second timeout with comprehensive error wrapping. All WebClient exceptions (connection failures, HTTP errors, timeouts) are caught and wrapped in DownstreamServiceException for consistent handling.

### Error Response Examples

**Validation Error (400):**
```json
{
  "status": 400,
  "code": "INVALID_PROMPT",
  "message": "Prompt is required and cannot be blank."
}
```

**Downstream Service Error (502):**
```json
{
  "status": 502,
  "code": "LLM_DOWN", 
  "message": "Failed to reach recipe generation service."
}
```

**Timeout Error (504):**
```json
{
  "status": 504,
  "code": "LLM_TIMEOUT",
  "message": "Recipe generation service timed out."
}
```

7. Downstream Service Contracts

The primary downstream dependency is the Python LLM service responsible for recipe generation.

**Request Contract:** This Java gateway will send a POST request to the Python service. The request body will be a JSON object mirroring the `RecipeRequest` model, containing the `prompt`, `dietaryPreferences`, and `cuisine`.

**Response Contract:** The Python service is expected to return a `200 OK` with a JSON body that strictly mirrors the `RecipeResponse` model defined in Section 4. The root object must contain a `recipes` array, where each element is a complete `Recipe` object.

## Downstream Error Responses

The Python FastAPI service returns structured error responses in the following format:

```json
{
    "code": "<ERROR_CODE>",
    "message": "<human readable message>"
}
```

### Error Scenarios

| HTTP Status | Error Code | Description | Example Trigger |
|-------------|------------|-------------|-----------------|
| 400 | `BAD_REQUEST` | Malformed JSON or invalid request structure | Invalid JSON syntax |
| 500 | `GENERATION_FAILED` | Unexpected error during recipe generation | Internal service exception |

### Example Error Responses

**Missing Prompt (400):**
```json
{
    "code": "INVALID_PROMPT",
    "message": "Prompt is required and cannot be blank."
}
```

**Malformed Request (400):**
```json
{
    "code": "BAD_REQUEST", 
    "message": "Malformed request or invalid JSON."
}
```

**Generation Failure (500):**
```json
{
    "code": "GENERATION_FAILED",
    "message": "Failed to generate recipe."
}
```

These structured error responses allow the Java gateway to handle downstream failures gracefully and provide meaningful feedback to clients.

8. Security (The Who)
   MVP

No authentication (open access for local testing).

Future (Production)

Authentication: API keys or OAuth2 via API Gateway.

Authorization: user-level recipe history.

Transport Security: enforce HTTPS.

Rate limiting: prevent abuse.

9. Observability

Logging: all requests, responses, errors ‚Üí CloudWatch.

Metrics: request count, latency, error rate.

Tracing: use request IDs to correlate across Java & Python services.

10. Open Questions (to refine later)

Should recipes be persisted immediately (DynamoDB) or only on-demand?

How do we handle multi-turn conversations (e.g., ‚Äúmake it spicier‚Äù)?


11. As of 11/19/25 replaced  `locale` with `Cuisine` field in `RecipeRequest` in the AutoChefJavaService.

12. As of 11/20/25 plumbed the `locale` to `Cuisine` field in the AutoChefPythonService. 
    Now Bedrock is returing recipes in the specified cusuine style.

13. As od 11/24/25 implemented DyanamoDb layer to store the receipes and also implemented a caching layer using redis run through locally with docker to cache the receipes . For now cache hit is based on entire prompt should match. But can improvise using semanctic caching with vector embeddings in future    