üìÑ AutoChef API Design Document
1. Overview

AutoChef is a GenAI-powered Recipe Generator.
This API is the Java Spring Boot service that acts as a gateway between clients (frontend, Postman, API Gateway) and the Python LLM service.

MVP Objective: Accept a prompt (e.g., "I have chicken and garlic") and return structured recipe suggestions.

Future Objective: Support recipe retrieval, user preferences, analytics, and caching via DynamoDB.

2. Principles

MVP-first: Start small with one endpoint (POST /generate-recipe).

Extensible: Design models and contracts with room to evolve (user preferences, locale, recipe IDs).

Production-minded: Separate concerns (Java gateway, Python LLM, DB layer).

Observability: Standard logging, error codes, CloudWatch integration later.

3. API Endpoints (The What)
   MVP

POST /generate-recipe
Accepts a free-text prompt and returns recipe suggestions.

Future Extensions

GET /recipes/{id} ‚Üí retrieve a specific recipe from DB.

GET /recipes/history ‚Üí list recipes generated by a user.

POST /recipes/feedback ‚Üí allow users to rate or refine recipes.

GET /health ‚Üí already available via Spring Actuator.

4. Data Models (The Nouns)
   RecipeRequest

Represents input from the user.

{
"prompt": "I have chicken and garlic",
"dietaryPreferences": ["low-carb"],
"locale": "en-US"
}


Fields:

prompt (string, required) ‚Üí User‚Äôs text describing ingredients or constraints.

dietaryPreferences (array[string], optional) ‚Üí Filters like "vegetarian", "gluten-free".

locale (string, optional) ‚Üí For localized instructions.

Recipe

Represents a recipe suggestion.

{
"title": "Garlic Chicken Stir Fry",
"ingredients": ["chicken", "garlic", "soy sauce", "vegetables"],
"instructions": "Heat oil, saut√© garlic, add chicken, stir-fry with vegetables and sauce.",
"cookTime": "20 minutes"
}


Fields:

title (string, required)

ingredients (array[string], required)

instructions (string, required)

cookTime (string, optional) ‚Üí Human-friendly format.

RecipeResponse

Wrapper for a list of recipes.

{
"recipes": [ { ...Recipe... } ]
}

ErrorResponse

Standard error object.

{
"code": "LLM_DOWN",
"message": "Failed to reach recipe generation service."
}


Fields:

code (string) ‚Üí machine-readable error code.

message (string) ‚Üí human-readable explanation.

5. Request/Response Payloads (The Conversation)
   Example Request
   POST /generate-recipe
   Content-Type: application/json

{
"prompt": "I have chicken and garlic",
"dietaryPreferences": ["low-carb"]
}

Example Success Response (200)
{
"recipes": [
{
"title": "Garlic Chicken Stir Fry",
"ingredients": ["chicken", "garlic", "soy sauce", "vegetables"],
"instructions": "Heat oil, saut√© garlic, add chicken, stir-fry with vegetables and sauce.",
"cookTime": "20 minutes"
}
]
}

Example Error Response (502)
{
"code": "LLM_DOWN",
"message": "Failed to reach recipe generation service."
}

6. Business Logic (The How)
   Flow for POST /generate-recipe

Input validation ‚Üí ensure prompt is present & non-empty.

Logging ‚Üí log request metadata (timestamp, request ID, prompt hash).

Forward to Python LLM Service ‚Üí call REST endpoint (mocked in MVP).

Response handling:

If success ‚Üí map response into RecipeResponse.

If failure ‚Üí return ErrorResponse with appropriate HTTP status.

Return to client ‚Üí JSON payload.

Error Handling Rules

400 Bad Request ‚Üí validation failed (e.g., empty prompt).

502 Bad Gateway ‚Üí Python LLM service unavailable.

500 Internal Server Error ‚Üí unexpected exceptions.

7. Security (The Who)
   MVP

No authentication (open access for local testing).

Future (Production)

Authentication: API keys or OAuth2 via API Gateway.

Authorization: user-level recipe history.

Transport Security: enforce HTTPS.

Rate limiting: prevent abuse.

8. Observability

Logging: all requests, responses, errors ‚Üí CloudWatch.

Metrics: request count, latency, error rate.

Tracing: use request IDs to correlate across Java & Python services.

9. Open Questions (to refine later)

Should recipes be persisted immediately (DynamoDB) or only on-demand?

How do we handle multi-turn conversations (e.g., ‚Äúmake it spicier‚Äù)?

Should we introduce versioning in the API path (/v1/generate-recipe)?